using System.Collections.Immutable;
using System.Text;
using HotChocolate.Types.Analyzers.Helpers;
using HotChocolate.Types.Analyzers.Inspectors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using static System.StringComparison;
using static HotChocolate.Types.Analyzers.Properties.SourceGenResources;
using static HotChocolate.Types.Analyzers.StringConstants;
using static HotChocolate.Types.Analyzers.WellKnownTypes;

namespace HotChocolate.Types.Analyzers.Generators;

public class DataLoaderGenerator : ISyntaxGenerator
{
    private static readonly DiagnosticDescriptor _keyParameterMissing =
        new(
            id: "HC0074",
            title: "Parameter Missing.",
            messageFormat:
            DataLoader_KeyParameterMissing,
            category: "DataLoader",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor _methodAccessModifierInvalid =
        new(
            id: "HC0075",
            title: "Access Modifier Invalid.",
            messageFormat:
            DataLoader_InvalidAccessModifier,
            category: "DataLoader",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);
    private static readonly DiagnosticDescriptor _invalidNumberOfParameters =
        new(
            id: "HC0010",
            title: "Invalid number of parameters.",
            messageFormat:
            Service_InvalidNumberOfParameters,
            category: "Service",
            DiagnosticSeverity.Error, 
            isEnabledByDefault: true);
          
    private static readonly DiagnosticDescriptor _invalidRequestType =
        new(
            id: "AB0011",
            title: "First argument must be MediatR.IRequest type.", 
            messageFormat:
            Service_InvalidRequestType, 
            category: "Service",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);
    
    private static readonly DiagnosticDescriptor _invalidCancellationTokenPlacement =
        new(
            id: "AB0012",
            title: "Last parameter must be a CancellationToken.",
            messageFormat:
            Service_InvalidCancellationTokenPlacement,
            category: "Service",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor _invalidReturnType =
        new(
            id: "AB0013",
            title: "Return type must be Task.",
            messageFormat:
            Service_InvalidReturnType,
            category: "Service",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorPostInitializationContext context) { }

    public bool Consume(ISyntaxInfo syntaxInfo)
        => syntaxInfo is DataLoaderInfo or ModuleInfo or DataLoaderDefaultsInfo;

    public void Generate(
        SourceProductionContext context,
        Compilation compilation,
        ReadOnlySpan<ISyntaxInfo> syntaxInfos)
    {
        var (module, defaults) = syntaxInfos.GetDataLoaderDefaults(compilation.AssemblyName);

        var dataLoaders = new List<DataLoaderInfo>();
        var sourceText = StringBuilderPool.Get();

        sourceText.AppendLine("// <auto-generated/>");
        sourceText.AppendLine("#nullable enable");
        sourceText.AppendLine("using System;");
        sourceText.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceText.AppendLine("using HotChocolate.Execution.Configuration;");

        foreach (var syntaxInfo in syntaxInfos)
        {
            if (syntaxInfo is not DataLoaderInfo dataLoader)
            {
                continue;
            }

            if (dataLoader.MethodSymbol.Parameters.Length < 2)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _invalidNumberOfParameters,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.ParameterList.Span)));
                continue;
            }

            if (dataLoader.MethodSymbol.DeclaredAccessibility is not Accessibility.Public
                and not Accessibility.Internal and not Accessibility.ProtectedAndInternal)
            {  
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _methodAccessModifierInvalid,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.Modifiers.Span)));
                continue;
            }
            var first = dataLoader.MethodSymbol.Parameters.FirstOrDefault()?.Type.Interfaces.FirstOrDefault();
            if(first is null || first.Name != "IRequest" || first.ContainingNamespace.Name != "MediatR")
            {
                // report
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _invalidRequestType,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.Modifiers.Span)));
                continue;
            }
            if (dataLoader.MethodSymbol.Parameters.LastOrDefault()?.Type.ToString() is not WellKnownTypes
                    .CancellationToken)
            {
                // report
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _invalidCancellationTokenPlacement,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.Modifiers.Span)));
                continue;
            }
            if (dataLoader.MethodSymbol.ReturnType.Name != "Task" && dataLoader.MethodSymbol.ReturnType.ContainingNamespace.Name != "System.Threading.Tasks")
            {
                // report
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _invalidReturnType,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.Modifiers.Span)));
                continue;
            }


            var method = new Method(dataLoader);
            var keyArg = dataLoader.MethodSymbol.Parameters[0];
            var keyType = keyArg.Type;
            var cancellationTokenIndex = -1;
            var serviceMap = new Dictionary<int, string>();

            if (IsKeysArgument(keyType))
            {
                keyType = ExtractKeyType(keyType);
            }

            InspectDataLoaderParameters(
                dataLoader,
                ref cancellationTokenIndex,
                serviceMap);

            DataLoaderKind kind;

            if (IsReturnTypeDictionary(dataLoader.MethodSymbol.ReturnType, keyType))
            {
                kind = DataLoaderKind.Batch;
            }
            else if (IsReturnTypeLookup(dataLoader.MethodSymbol.ReturnType, keyType))
            {
                kind = DataLoaderKind.Group;
            }
            else
            {
                keyType = keyArg.Type;
                kind = DataLoaderKind.Cache;
            }

            var valueType = ExtractValueType(dataLoader.MethodSymbol.ReturnType, kind);

            dataLoaders.Add(dataLoader);

            GenerateDataLoader(
                method,
                dataLoader,
                defaults,
                kind,
                keyType,
                valueType,
                dataLoader.MethodSymbol.Parameters.Length,
                cancellationTokenIndex,
                serviceMap,
                sourceText);
        }

        // if we find no valid DataLoader we will not create any file.
        if (dataLoaders.Count > 0)
        {
            if (defaults.RegisterServices)
            {
                // write DI integration
                sourceText.AppendLine();
                sourceText.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
                sourceText.AppendLine("{");
                GenerateDataLoaderRegistrations(module, dataLoaders, sourceText);
                sourceText.AppendLine("}");
            }

            context.AddSource(
                WellKnownFileNames.DataLoaderFile,
                SourceText.From(sourceText.ToString(), Encoding.UTF8));
        }

        StringBuilderPool.Return(sourceText);
    }

    private static void GenerateDataLoader(Method method,
        DataLoaderInfo dataLoader,
        DataLoaderDefaultsInfo defaults,
        DataLoaderKind kind,
        ITypeSymbol keyType,
        ITypeSymbol valueType,
        int parameterCount,
        int cancelIndex,
        Dictionary<int, string> services,
        StringBuilder sourceText)
    {
        var isScoped = dataLoader.IsScoped ?? defaults.Scoped ?? false;
        var isPublic = dataLoader.IsPublic ?? defaults.IsPublic ?? true;
        var isInterfacePublic = dataLoader.IsInterfacePublic ?? defaults.IsInterfacePublic ?? true;

        sourceText.AppendLine();
        sourceText.Append("namespace ");
        sourceText.AppendLine(dataLoader.Namespace);
        sourceText.AppendLine("{");

        // first we generate a DataLoader interface ...
        // var interfaceName = dataLoader.InterfaceName;
        //
        // if (isInterfacePublic)
        // {
        //     sourceText.Append("    public interface ");
        // }
        // else
        // {
        //     sourceText.Append("    internal interface ");
        // }
        //
        // sourceText.Append(interfaceName);
        //
        // if (kind is DataLoaderKind.Batch or DataLoaderKind.Cache)
        // {
        //     sourceText.Append(" : global::GreenDonut.IDataLoader<");
        //     sourceText.Append(keyType.ToFullyQualified());
        //     sourceText.Append(", ");
        //     sourceText.Append(valueType.ToFullyQualified());
        //     sourceText.Append(">");
        // }
        // else if (kind is DataLoaderKind.Group)
        // {
        //     sourceText.Append(" : global::GreenDonut.IDataLoader<");
        //     sourceText.Append(keyType.ToFullyQualified());
        //     sourceText.Append(", ");
        //     sourceText.Append(valueType.ToFullyQualified());
        //     sourceText.Append("[]>");
        // }
        //
        // sourceText.AppendLine(" { }");
        // sourceText.AppendLine();

        // ... then the actual DataLoader implementation.
        if (isPublic)
        {
            sourceText.Append("    public sealed class ");
        }
        else
        {
            sourceText.Append("    internal sealed class ");
        }

        sourceText.Append(dataLoader.Name);

        sourceText.Append(" : global::MediatR.IRequestHandler<");
        sourceText.Append(method.Request.Type.ToFullyQualified());
        if (method.Response is not null)
        {
            sourceText.Append(", ");
            sourceText.Append(method.Response!.ToFullyQualified());
        }
        
        sourceText.Append(">");
        
        // if (kind is DataLoaderKind.Batch)
        // {
        //     
        // }
        // else if (kind is DataLoaderKind.Group)
        // {
        //     sourceText.Append(" : global::GreenDonut.GroupedDataLoader<");
        //     sourceText.Append(keyType.ToFullyQualified());
        //     sourceText.Append(", ");
        //     sourceText.Append(valueType.ToFullyQualified());
        //     sourceText.Append(">");
        // }
        // else if (kind is DataLoaderKind.Cache)
        // {
        //     sourceText.Append(" : global::GreenDonut.CacheDataLoader<");
        //     sourceText.Append(keyType.ToFullyQualified());
        //     sourceText.Append(", ");
        //     sourceText.Append(valueType.ToFullyQualified());
        //     sourceText.Append(">");
        // }

        // sourceText.Append(", ");
        // sourceText.AppendLine(interfaceName);
        sourceText.AppendLine("    {");
        foreach (var parameter in method.Services)
        {
            sourceText.AppendLine(
                $"        private readonly {parameter.Type.ToFullyQualified()} _{parameter.Name};");
        }
        sourceText.AppendLine();
        sourceText
            .Append(Indent)
            .Append(Indent)
            .Append("public ")
            .Append(dataLoader.Name)
            .AppendLine("(");
        for (int i = 0; i < method.Services.Length; i++)
        {      
            if (i > 0)
            {
                sourceText.Append(",");
                sourceText.AppendLine();
            }
            var parameter = method.Services[i];
            sourceText
                .Append(Indent)
                .Append(Indent)
                .Append(Indent)
                .Append(
                    $"{parameter.Type.ToFullyQualified()} {parameter.Name}");
        } 

        sourceText.AppendLine(")");
        sourceText.AppendLine("        {");
        foreach (var parameter in method.Services)
        {
            sourceText.AppendLine($"            _{parameter.Name} = {parameter.Name} ??");
            sourceText.Append("                throw new global::")
                .AppendLine($"System.ArgumentNullException(nameof({parameter.Name}));");
        }

        var request = method.Request;
        sourceText.AppendLine("        }");
        sourceText.AppendLine();
        sourceText.Append($"        public ");
        if (method.Response is not null)
        {
            sourceText.Append($"global::{WellKnownTypes.Task}<");
            sourceText.Append(method.Response.ToFullyQualified());
            sourceText.Append("> ");
        }
        else
        { 
            sourceText.Append($"global::{WellKnownTypes.Task} ");
        }
        sourceText.AppendLine("Handle(");
        sourceText.AppendLine($"            {request.Type.ToFullyQualified()} {request.Name},");   
        sourceText.AppendLine($"            global::{WellKnownTypes.CancellationToken} cancellationToken)");
        sourceText.AppendLine("        {");
  
        sourceText.Append("            return ");
        sourceText.Append(dataLoader.ContainingType);
        sourceText.Append(".");
        sourceText.Append(dataLoader.MethodName);
        sourceText.Append("(");
        sourceText.Append($"{method.Request.Name}, ");
        for (var i = 0; i < method.Services.Length; i++)
        {
            if (i > 0)
            {
                sourceText.Append(", ");
            }
            sourceText.Append($"_{method.Services[i].Name}");
        }
        sourceText.Append(", cancellationToken);");
        sourceText.AppendLine("        }");
        sourceText.AppendLine("    }");
        sourceText.AppendLine("}");
    }

    private static void GenerateDataLoaderRegistrations( 
        ModuleInfo module,
        List<DataLoaderInfo> dataLoaders,
        StringBuilder sourceText)
    {
        sourceText.Append(Indent)
            .Append("public static partial class ")
            .Append(module.ModuleName)
            .AppendLine("RequestExecutorBuilderExtensions");

        sourceText
            .Append(Indent)
            .AppendLine("{");

        sourceText
            .Append(Indent)
            .Append(Indent)
            .Append("static partial void RegisterGeneratedDataLoader(")
            .AppendLine("IRequestExecutorBuilder builder)");

        sourceText
            .Append(Indent)
            .Append(Indent)
            .AppendLine("{");

        foreach (var dataLoader in dataLoaders)
        {
            sourceText
                .Append(Indent)
                .Append(Indent)
                .Append(Indent)
                .Append("builder.AddDataLoader<")
                .Append(dataLoader.InterfaceFullName)
                .Append(", ")
                .Append(dataLoader.FullName)
                .AppendLine(">();");
        }

        sourceText
            .Append(Indent)
            .Append(Indent)
            .AppendLine("}");

        sourceText
            .Append(Indent)
            .AppendLine("}");
    }

    private void InspectDataLoaderParameters(
        DataLoaderInfo dataLoader,
        ref int cancellationTokenIndex,
        Dictionary<int, string> serviceMap)
    {
        for (var i = 1; i < dataLoader.MethodSymbol.Parameters.Length; i++)
        {
            var argument = dataLoader.MethodSymbol.Parameters[i];
            var argumentType = argument.Type.ToFullyQualified();

            if (IsCancellationToken(argumentType))
            {
                if (cancellationTokenIndex != -1)
                {
                    // report error
                    return;
                }

                cancellationTokenIndex = i;
            }
            else
            {
                serviceMap[i] = argumentType;
            }
        }
    }

    private static bool IsKeysArgument(ITypeSymbol type)
        => type is INamedTypeSymbol { IsGenericType: true, TypeArguments.Length: 1 } nt &&
            ReadOnlyList.Equals(ToTypeNameNoGenerics(nt), Ordinal);

    private static ITypeSymbol ExtractKeyType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, TypeArguments.Length: 1 } namedType &&
            ReadOnlyList.Equals(ToTypeNameNoGenerics(namedType), Ordinal))
        {
            return namedType.TypeArguments[0];
        }

        throw new InvalidOperationException();
    }

    private static bool IsCancellationToken(string typeName)
        => string.Equals(typeName, WellKnownTypes.CancellationToken) ||
            string.Equals(typeName, GlobalCancellationToken);

    private static bool IsReturnTypeDictionary(ITypeSymbol returnType, ITypeSymbol keyType)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
        {
            var resultType = namedType.TypeArguments[0];

            if (IsReadOnlyDictionary(resultType) &&
                resultType is INamedTypeSymbol { TypeArguments.Length: 2 } dictionaryType &&
                dictionaryType.TypeArguments[0].Equals(keyType, SymbolEqualityComparer.Default))
            {
                return true;
            }
        }
        return false;
    }

    private static bool IsReturnTypeLookup(ITypeSymbol returnType, ITypeSymbol keyType)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
        {
            var resultType = namedType.TypeArguments[0];

            if (ToTypeNameNoGenerics(resultType).Equals(Lookup, Ordinal) &&
                resultType is INamedTypeSymbol { TypeArguments.Length: 2 } dictionaryType &&
                dictionaryType.TypeArguments[0].Equals(keyType, SymbolEqualityComparer.Default))
            {
                return true;
            }
        }
        return false;
    }

    private static bool IsReadOnlyDictionary(ITypeSymbol type)
    {
        if (!ToTypeNameNoGenerics(type).Equals(ReadOnlyDictionary, Ordinal))
        {
            foreach (var interfaceSymbol in type.Interfaces)
            {
                if (ToTypeNameNoGenerics(interfaceSymbol).Equals(ReadOnlyDictionary, Ordinal))
                {
                    return true;
                }
            }

            return false;
        }

        return true;
    }

    private static ITypeSymbol ExtractValueType(ITypeSymbol returnType, DataLoaderKind kind)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1 } namedType)
        {
            if (kind is DataLoaderKind.Batch or DataLoaderKind.Group &&
                namedType.TypeArguments[0] is INamedTypeSymbol { TypeArguments.Length: 2 } dict)
            {
                return dict.TypeArguments[1];
            }

            if (kind is DataLoaderKind.Cache)
            {
                return namedType.TypeArguments[0];
            }
        }

        throw new InvalidOperationException();
    }

    private static string ToTypeNameNoGenerics(ITypeSymbol typeSymbol)
        => $"{typeSymbol.ContainingNamespace}.{typeSymbol.Name}";
}

internal static class GeneratorUtils
{
    public static ModuleInfo GetModuleInfo(
        this ReadOnlySpan<ISyntaxInfo> syntaxInfos,
        string? assemblyName,
        out bool defaultModule)
    {
        foreach (var syntaxInfo in syntaxInfos)
        {
            if (syntaxInfo is ModuleInfo module)
            {
                defaultModule = false;
                return module;
            }
        }

        defaultModule = true;
        return new ModuleInfo(CreateModuleName(assemblyName), ModuleOptions.Default);
    }

    public static (ModuleInfo, DataLoaderDefaultsInfo) GetDataLoaderDefaults(
        this ReadOnlySpan<ISyntaxInfo> syntaxInfos,
        string? assemblyName)
    {
        ModuleInfo? moduleInfo = null;
        DataLoaderDefaultsInfo? dataLoaderDefaultsInfo = null;

        foreach (var syntaxInfo in syntaxInfos)
        {
            if (moduleInfo is null && syntaxInfo is ModuleInfo mi)
            {
                moduleInfo = mi;
            }
            else if (dataLoaderDefaultsInfo is null && syntaxInfo is DataLoaderDefaultsInfo dldi)
            {
                dataLoaderDefaultsInfo = dldi;
            }

            if (moduleInfo is not null && dataLoaderDefaultsInfo is not null)
            {
                return (moduleInfo, dataLoaderDefaultsInfo);
            }
        }

        moduleInfo ??= new ModuleInfo(CreateModuleName(assemblyName), ModuleOptions.Default);
        dataLoaderDefaultsInfo ??= new DataLoaderDefaultsInfo(null, null, true, true);

        return (moduleInfo, dataLoaderDefaultsInfo);
    }

    private static string CreateModuleName(string? assemblyName)
        => assemblyName is null
            ? "AssemblyTypes"
            : assemblyName.Split('.').Last() + "Types";
}